org 100h    ; آدرس دهی تفاوت مکان برای شروع برنامه
.data   ; پیاده سازی سگمنت داده

array  db 9,6,5,4,3,2,1   ; تعریف آرایه از اعداد دهدهی به صورت تعریف بایت برای هر عضو
length  dw 7               ; تعریف کاردینال آرایه به صورت دوبایتی یا یک کلمه

.code   ; پیاده سازی سگمنت کد

    mov cx,length          ; مقدار کاردینال آرایه را در ثبات شمارشگر بار می کنیم
    dec cx                ; یک واحد از ثبات شمارشگر را کم می کنیم تا تعداد مقاسیه لازم در هر پیمایش را به دست آوریم

iteronarray:                 ; پیاده سازی رویه پیمایش روی اعضای حلقه
    mov bx,cx ; بار کردن تعداد مقایسه لازم در هر پیمایش در ثبات بی-ایکس
    mov si,0             ; بار کردن مقدار اندیس عضو اول آرایه یعنی صفر در ثبات ایندکس-سورس

cmponarray:                 ; پیاده سازی رویه مقایسه دو عنصر مجاور
    mov al,array[si]     ; بار کردن مقدار عنصر اول در ثبات ا-ال
    mov dl,array[si+1]   ; بار کردن مقدار عنصر بعدی در ثبات دی-ال
    cmp al,dl            ; مقایسه مقادیر دو عنصر

    jnc noswap           ; در صورتی که مقدار بار شده در ثبات ا-ال یعنی همان عنصر اولی بزرگتر مساوی مقدار بار شده در ثبات دی-ال باشد یعنی همان عنصر دومی پرش رخ میدهد

;; در واقع پرش به رویه ای رخ می دهد تا از عمل جابه جایی یا سواپ عنصر اولی و دومی پیشگیری کند زیرا فرض کرده ایم که مرتب سازی ما نزولی است و در صورتی که عنصر اولی بزرگتر از عنصر دومی باشد نباید عمل سواپ یا جابه جایی صورت گیرد

;; اما در صورتی که عنصر اولی کوچکتر از دومی بود باید این دو عنصر را سواپ کنیم
    mov array[si],dl
    mov array[si+1],al

;; پیاده سازی رویه که از رویه مقایسه در شرایطی که سواپ رخ نداد باشد به این رویه پرش خواهد کرد تا ادامه پیمایش نیز دنبال شود

noswap:
    inc si               ; یک واحد افزایش ثبات ایندکس برای ایندکس عنصر بعدی

    dec bx ; با انجام یک مقایسه یک واحد از مقایسه های لازم را کم میکنیم
    jnz cmponarray; تا زمانی که مقایسه لازم باشد یعنی مقدار ثبات بی-ایکس مخالف صفر باشد پیمایش و مقایسه عناصر ادامه دارد یعنی پرش به رویه مقایسه رخ می دهد

    ;; زمانی که پیمایش روی آرایه به عنصر آخر رسید و رویه مقایسه اجرا شد میدانیم حال عنصر آخر در مکان درست قرار دارد به عبارتی کوچکترین عضو آرایه است پس حلقه را برای سایر اعضا ادامه میدهیم تا به عنصر اول برسیم و این را به وسیله حلقه پیاده سازی میکنیم

    loop iteronarray    ; با استفاده از دستور حلقه بار دیگر پیمایش روی آرایه را با یک واحد کاهش مقدار ثبات شمارشگر یا سی-ایکس ادامه میدهیم تا زمانی که مقدار آن برابر صفر شده باشد به معنی اینکه آرایه مرتب شده باشد

;;; نمایش آرایه مرتب شده به کاربر

    mov cx,length
    mov si,0

print:
    mov al, array[si]
    add al, 30h
    mov ah, 0eh
    int 10h

    mov al, ' '
    int 10h

    inc si
    loop print
    
    ret